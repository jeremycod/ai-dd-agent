import { AgentStateData } from '../model/agentState';
import { Offer } from '../model/types/offerService'; // Import Offer type
import { AIMessage, BaseMessage, ToolMessage } from '@langchain/core/messages';
import { fetchOfferServiceOfferTool } from '../tools/offerServiceTools'; // Keep importing the tool output type
import { logger } from '../utils/logger';

function generateNewAIMessage(content: string): AIMessage {
  return new AIMessage(content);
}

export async function fetchOfferServiceOffer(
  state: AgentStateData,
): Promise<Partial<AgentStateData>> {
  logger.info(
    '[Node: fetchOfferServiceOfferNode] Attempting to fetch Offer Service Offer details...',
  );

  const { entityType, entityIds, messages, environment } = state;

  if (entityType !== 'offer' || !entityIds || entityIds.length === 0) {
    logger.warn(
      '[Node: fetchOfferServiceOfferNode] Skipping: Not an offer query or no offer IDs provided.',
    );
    return {
      messages: [
        ...messages,
        generateNewAIMessage(
          'Offer Service details fetching skipped: not an offer query or no specific IDs provided.',
        ),
      ],
      offerServiceDetails: state.offerServiceDetails || [],
      analysisResults: {
        ...state.analysisResults,
        offerServiceDetails: 'Offer Service details not fetched (not an offer query or no IDs).',
      },
    };
  }

  const fetchedOffers: Offer[] = []; // To store the actual Offer objects
  const newMessages: BaseMessage[] = []; // To accumulate all messages generated by this node
  const failedFetches: string[] = []; // To store failed offer IDs
  const analysisResultMessages: string[] = []; // For collecting messages for the analysisResults summary

  for (const offerId of entityIds) {
    try {
      const toolCallResult: { offer: Offer | null; message: string } =
        await fetchOfferServiceOfferTool.invoke({
          offerId: offerId,
          environment: environment,
        });


      if (toolCallResult.offer) {
        // If the tool returns an offer object, it's a success
        fetchedOffers.push(toolCallResult.offer);
        newMessages.push(
          generateNewAIMessage(`Successfully fetched details for offer \`${offerId}\`.`),
        );
        analysisResultMessages.push(`Offer ID ${offerId}: ${toolCallResult.message}`); // Add tool's success message to analysis summary
      } else {
        // If the tool returns a null offer (but a message), it indicates an error or no offer found
        newMessages.push(
          generateNewAIMessage(`Tool output for offer ${offerId}: ${toolCallResult.message}`),
        );
        failedFetches.push(offerId);
        analysisResultMessages.push(`Offer ID ${offerId}: ${toolCallResult.message}`); // Add tool's failure message to analysis summary
      }
    } catch (error: any) {
      logger.error(
        `[Node: fetchOfferServiceOfferNode] Error invoking tool for offer ${offerId}:`,
        error,
      );
      const errorMessage = `Failed to retrieve details for offer \`${offerId}\` due to an unexpected error. Error: ${error.message}`;

      // Add an AIMessage about the error
      newMessages.push(generateNewAIMessage(errorMessage));
      failedFetches.push(offerId);
      analysisResultMessages.push(`Offer ID ${offerId}: ${errorMessage}`); // Add to analysis summary

      // Add a ToolMessage for the error as well, reflecting the tool's failed execution
      newMessages.push(
          generateNewAIMessage(
              `Failed to retrieve offer from offer service for \`${offerId}\` due to an error: ${error.message}.`
          )
      );
    }
  }

  let summaryMessage = `Offer Service fetching completed for ${entityIds.length} offers.`;
  if (fetchedOffers.length > 0) {
    summaryMessage += ` Successfully retrieved ${fetchedOffers.length}.`;
  }
  if (failedFetches.length > 0) {
    summaryMessage += ` Failed for ${failedFetches.length} offers: ${failedFetches.join(', ')}.`;
  }
  newMessages.push(generateNewAIMessage(summaryMessage)); // Add the final summary message

  // This will be the detailed summary for analysisResults, combining all individual tool results
  const combinedOfferServiceSummary =
    analysisResultMessages.length > 0
      ? analysisResultMessages.join('\n\n---\n\n') // Combine all individual messages/summaries from tool calls
      : failedFetches.length > 0
        ? `Failed to retrieve any offer details: ${failedFetches.join(', ')}`
        : 'No offer details fetched.';

  return {
    messages: [...messages, ...newMessages], // Prepend original messages, append all new ones from this node
    offerServiceDetails: fetchedOffers.length > 0 ? fetchedOffers : undefined,
    analysisResults: {
      ...state.analysisResults,
      offerServiceDetails: combinedOfferServiceSummary, // This is now the detailed combined summary
    },
  };
}
